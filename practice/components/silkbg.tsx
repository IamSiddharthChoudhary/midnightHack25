"use client"

import { useEffect, useRef } from "react"
import * as THREE from "three"

export function BgComponent() {
  const containerRef = useRef<HTMLDivElement>(null)
  const canvasRef = useRef<HTMLDivElement>(null)
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null)
  
  const materialsRef = useRef<{
    fluidMaterial: THREE.ShaderMaterial | null;
    displayMaterial: THREE.ShaderMaterial | null;
  }>({ fluidMaterial: null, displayMaterial: null })
  
  const mouseRef = useRef({ x: 0, y: 0, prevX: 0, prevY: 0, lastMoveTime: 0 })

  useEffect(() => {
    if (!containerRef.current || !canvasRef.current) return

    const vertexShader = `
      varying vec2 vUv;
      void main(){
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `

    const fluidShader = `
      uniform float iTime;
      uniform vec2 iResolution;
      uniform vec4 iMouse;
      uniform int iFrame;
      uniform sampler2D iPreviousFrame;
      uniform float uBrushSize;
      uniform float uBrushStrength;
      uniform float uFluidDecay;
      uniform float uTrailLength;
      uniform float uStopDecay;
      varying vec2 vUv;

      vec2 ur, U;

      float ln(vec2 p, vec2 a, vec2 b) {
        return length(p - a - (b - a) * clamp(dot(p - a, b - a) / dot(b - a, b - a), 0.0, 1.0));
      }
      
      vec4 t(vec2 v, int a, int b) {
        return texture2D(iPreviousFrame, fract((v + vec2(float(a), float(b))) / ur));
      }
      
      vec4 t(vec2 v) {
        return texture2D(iPreviousFrame, fract(v / ur));
      }

      float area(vec2 a, vec2 b, vec2 c) {
        float A = length(b - c), B = length(c - a), C = length(a - b), s = 0.5 * (A + B + C);
        return sqrt(max(0.0, s * (s - A) * (s - B) * (s - C))); 
      }

      void main() {
        U = vUv * iResolution;
        ur = iResolution.xy;

        if (iFrame < 1) {
          float w = 0.5 + sin(0.2 * U.x) * 0.5;
          float q = length(U - 0.5 * ur);
          gl_FragColor = vec4(0.1 * exp(-0.001 * q), 0.0, w, 1.0);
        } else {
          vec2 v = U;
          vec2 A = v + vec2(1, 1);
          vec2 B = v + vec2(1, -1);
          vec2 C = v + vec2(-1, 1);
          vec2 D = v + vec2(-1, -1);

          for (int i = 0; i < 8; i++) {
            v -= t(v).xy;
            A -= t(A).xy;
            B -= t(B).xy;
            C -= t(C).xy;
            D -= t(D).xy;
          }

          vec4 me = t(v);
          vec4 n = t(v, 0, 1);
          vec4 e = t(v, 1, 0);
          vec4 s = t(v, 0, -1);
          vec4 w = t(v, -1, 0);
          vec4 ne = 0.25 * (n + e + s + w);
          me = mix(t(v), ne, vec4(0.15, 0.15, 0.95, 0.0));
          me.z = me.z - 0.01 * ((area(A, B, C) + area(B, C, D)) - 4.0);

          vec4 pr = vec4(e.z, w.z, n.z, s.z);
          me.xy = me.xy + 100.0 * vec2(pr.x - pr.y, pr.z - pr.w) / ur;

          me.xy *= uFluidDecay;
          me.z *= uTrailLength;
          
          if (iMouse.z > 0.0) {
            vec2 mousePos = iMouse.xy;
            vec2 mousePrev = iMouse.zw;
            vec2 mouseVel = mousePos - mousePrev;
            float velMagnitude = length(mouseVel);
            float q = ln(U, mousePos, mousePrev);
            vec2 m = mousePos - mousePrev;
            float l = length(m);
            if (l > 0.0) m = min(10.0, 10.0) * m / l;

            float brushSizeFactor = 1e-4 / uBrushSize;
            float strengthFactor = 0.03 * uBrushStrength;

            float falloff = exp(-brushSizeFactor * q * q * q);
            falloff = pow(falloff, 0.5);

            me.xyz += strengthFactor * falloff * vec3(m, 10.0);

            if (velMagnitude < 2.0) {
              float distToCursor = length(U - mousePos);
              float influence = exp(-distToCursor * 0.01);
              float cursorDecay = mix(1.0, uStopDecay, influence);
              me.xy *= cursorDecay;
              me.z *= cursorDecay;
            }
          }

          gl_FragColor = clamp(me, -0.4, 0.4);
        }
      }
    `

    const displayShader = `
      uniform float iTime;
      uniform vec2 iResolution;
      uniform sampler2D iFluid;
      uniform float uDistortionAmount;
      uniform vec3 uColor1;
      uniform vec3 uColor2;
      uniform vec3 uColor3;
      uniform vec3 uColor4;
      uniform float uColorIntensity;
      uniform float uSoftness;
      varying vec2 vUv;

      void main() {
        vec2 fragCoord = vUv * iResolution;

        vec4 fluid = texture2D(iFluid, vUv);
        vec2 fluidVel = fluid.xy;

        float mr = min(iResolution.x, iResolution.y);
        vec2 uv = (fragCoord * 2.0 - iResolution.xy) / mr;

        uv += fluidVel * (0.5 * uDistortionAmount);

        float d = -iTime * 0.5;
        float a = 0.0;
        for (float i = 0.0; i < 8.0; ++i) {
          a += cos(i - d - a * uv.x);
          d += sin(uv.y * i + a);
        }

        d += iTime * 0.5;

        float mixer1 = cos(uv.x * d) * 0.5 + 0.5;
        float mixer2 = cos(uv.y * a) * 0.5 + 0.5;
        float mixer3 = sin(d + a) * 0.5 + 0.5;

        float smoothAmount = clamp(uSoftness * 0.1, 0.0, 0.9);
        mixer1 = mix(mixer1, 0.5, smoothAmount);
        mixer2 = mix(mixer2, 0.5, smoothAmount);
        mixer3 = mix(mixer3, 0.5, smoothAmount);

        vec3 col = mix(uColor1, uColor2, mixer1);
        col = mix(col, uColor3, mixer2);
        col = mix(col, uColor4, mixer3 * 0.4);

        col *= uColorIntensity;

        gl_FragColor = vec4(col, 1.0);
      }
    `

    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1)
    const renderer = new THREE.WebGLRenderer({ antialias: true })
    rendererRef.current = renderer

    renderer.setSize(window.innerWidth, window.innerHeight)
    canvasRef.current.appendChild(renderer.domElement)

    const fluidTarget1 = new THREE.WebGLRenderTarget(
      window.innerWidth,
      window.innerHeight,
      {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat,
        type: THREE.FloatType,
      }
    )

    const fluidTarget2 = new THREE.WebGLRenderTarget(
      window.innerWidth,
      window.innerHeight,
      {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat,
        type: THREE.FloatType,
      }
    )

    let currentFluidTarget = fluidTarget1
    let previousFluidTarget = fluidTarget2
    let frameCount = 0

    const fluidMaterial = new THREE.ShaderMaterial({
      uniforms: {
        iTime: { value: 0 },
        iResolution: {
          value: new THREE.Vector2(window.innerWidth, window.innerHeight),
        },
        iMouse: { value: new THREE.Vector4(0, 0, 0, 0) },
        iFrame: { value: 0 },
        iPreviousFrame: { value: null },
        uBrushSize: { value: 25 },
        uBrushStrength: { value: 0.5 },
        uFluidDecay: { value: 0.98 },
        uTrailLength: { value: 0.8 },
        uStopDecay: { value: 0.85 },
      },
      vertexShader,
      fragmentShader: fluidShader,
    })

    const displayMaterial = new THREE.ShaderMaterial({
      uniforms: {
        iTime: { value: 0 },
        iResolution: {
          value: new THREE.Vector2(window.innerWidth, window.innerHeight),
        },
        iFluid: { value: null },
        uDistortionAmount: { value: 2.5 },
        uColor1: { value: new THREE.Vector3(0.3803921568627451, 0.396078431372549, 0.396078431372549) },
        uColor2: { value: new THREE.Vector3(0.30196078431372547, 0.29411764705882354, 0.3254901960784314) },
        uColor3: { value: new THREE.Vector3(0.0196078431372549, 0.03529411764705882, 0.0784313725490196) },
        uColor4: { value: new THREE.Vector3(0, 0, 0) },
        uColorIntensity: { value: 1.0 },
        uSoftness: { value: 1.0 }
      },
      vertexShader,
      fragmentShader: displayShader,
    })

    materialsRef.current = { fluidMaterial, displayMaterial }

    const geometry = new THREE.PlaneGeometry(2, 2)
    const fluidPlane = new THREE.Mesh(geometry, fluidMaterial)
    const displayPlane = new THREE.Mesh(geometry, displayMaterial)

    function animate() {
      requestAnimationFrame(animate)

      const time = performance.now() * 0.001
      fluidMaterial.uniforms.iTime.value = time
      displayMaterial.uniforms.iTime.value = time
      fluidMaterial.uniforms.iFrame.value = frameCount

      if (performance.now() - mouseRef.current.lastMoveTime > 100) {
        fluidMaterial.uniforms.iMouse.value.set(0, 0, 0, 0)
      }

      fluidMaterial.uniforms.iPreviousFrame.value = previousFluidTarget.texture

      renderer.setRenderTarget(currentFluidTarget)
      renderer.render(fluidPlane, camera)

      displayMaterial.uniforms.iFluid.value = currentFluidTarget.texture

      renderer.setRenderTarget(null)
      renderer.render(displayPlane, camera)

      const temp = currentFluidTarget
      currentFluidTarget = previousFluidTarget
      previousFluidTarget = temp

      frameCount++
    }

    const handleResize = () => {
      const width = window.innerWidth
      const height = window.innerHeight

      renderer.setSize(width, height)
      fluidMaterial.uniforms.iResolution.value.set(width, height)
      displayMaterial.uniforms.iResolution.value.set(width, height)

      fluidTarget1.setSize(width, height)
      fluidTarget2.setSize(width, height)
      frameCount = 0
    }

    window.addEventListener("resize", handleResize)
    animate()

    return () => {
      window.removeEventListener("resize", handleResize)
      renderer.dispose()
      fluidTarget1.dispose()
      fluidTarget2.dispose()
      geometry.dispose()
      fluidMaterial.dispose()
      displayMaterial.dispose()
      materialsRef.current = { fluidMaterial: null, displayMaterial: null }
      rendererRef.current = null
    }
  }, [])

  useEffect(() => {
    const canvas = rendererRef.current?.domElement
    if (!canvas) return

    const handleMouseMove = (e: MouseEvent) => {
      if (!true || !materialsRef.current.fluidMaterial) return

      const rect = canvas.getBoundingClientRect()

      mouseRef.current.prevX = mouseRef.current.x
      mouseRef.current.prevY = mouseRef.current.y

      mouseRef.current.x = e.clientX - rect.left
      mouseRef.current.y = rect.height - (e.clientY - rect.top)
      mouseRef.current.lastMoveTime = performance.now()

      materialsRef.current.fluidMaterial.uniforms.iMouse.value.set(
        mouseRef.current.x,
        mouseRef.current.y,
        mouseRef.current.prevX,
        mouseRef.current.prevY
      )
    }

    const handleMouseLeave = () => {
      if (materialsRef.current.fluidMaterial) {
        materialsRef.current.fluidMaterial.uniforms.iMouse.value.set(
          0,
          0,
          0,
          0
        )
      }
    }

    canvas.addEventListener("mousemove", handleMouseMove)
    canvas.addEventListener("mouseleave", handleMouseLeave)

    if (!true && materialsRef.current.fluidMaterial) {
      materialsRef.current.fluidMaterial.uniforms.iMouse.value.set(0, 0, 0, 0)
    }

    return () => {
      canvas.removeEventListener("mousemove", handleMouseMove)
      canvas.removeEventListener("mouseleave", handleMouseLeave)
    }
  }, [])

  return (
   <div ref={containerRef} className="opacity-85 relative w-full h-screen overflow-hidden bg-black pointer-events-auto">
      <div ref={canvasRef} className="fixed top-0 left-0 w-full h-full pointer-events-auto" />
    </div>
  )
}